name: Release macOS App

on:
  push:
    tags:
      - "v*"

  workflow_dispatch:
    inputs:
      version:
        description: "Version number (e.g., 1.0.0)"
        required: false
        type: string

env:
  SCHEME: "Github Actions Sandbox"
  PROJECT: "Github Actions Sandbox.xcodeproj"
  PRODUCT_NAME: "Github Actions Sandbox"
  DMG_BACKGROUND_FILE_NAME: "Assets/background@2x.png"

jobs:
  build:
    runs-on: macos-26

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Get version
        id: version
        run: |
          if [ -n "${{ inputs.version }}" ]; then
            echo "version=${{ inputs.version }}" >> $GITHUB_OUTPUT
          elif [[ "$GITHUB_REF" == refs/tags/v* ]]; then
            echo "version=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
          else
            echo "version=$(date +%Y%m%d%H%M%S)" >> $GITHUB_OUTPUT
          fi

      - name: Select Xcode
        run: |
          sudo xcode-select -s /Applications/Xcode_26.1.app/Contents/Developer
          xcodebuild -version

      - name: Set version in Xcode project
        run: |
          sed -i '' 's/MARKETING_VERSION = [^;]*;/MARKETING_VERSION = ${{ steps.version.outputs.version }};/g' "$PROJECT/project.pbxproj"
          sed -i '' 's/CURRENT_PROJECT_VERSION = [^;]*;/CURRENT_PROJECT_VERSION = ${{ steps.version.outputs.version }};/g' "$PROJECT/project.pbxproj"

      - name: Import Code Signing Certificate
        env:
          CERTIFICATE_BASE64: ${{ secrets.CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Decode certificate from base64
          echo -n "$CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate to keychain
          security import $CERTIFICATE_PATH -P "$CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

      - name: Prepare Entitlements for CI Build
        env:
          DEVELOPMENT_TEAM: ${{ secrets.DEVELOPMENT_TEAM }}
        run: |
          # Set CODE_SIGN_STYLE to Manual in project file
          sed -i '' 's/CODE_SIGN_STYLE = Automatic;/CODE_SIGN_STYLE = Manual;/g' "$PROJECT/project.pbxproj"
          # Disable REGISTER_APP_GROUPS to avoid provisioning profile requirement
          sed -i '' 's/REGISTER_APP_GROUPS = YES;/REGISTER_APP_GROUPS = NO;/g' "$PROJECT/project.pbxproj"

          # Create a build-time entitlements without keychain-access-groups (causes profile requirement)
          # Save original for later re-signing
          ENTITLEMENTS_FILE=$(find . -name "*.entitlements" -print -quit)
          cp "$ENTITLEMENTS_FILE" "$RUNNER_TEMP/original.entitlements"

          # Replace $(AppIdentifierPrefix) with Team ID in the original (for re-signing later)
          sed -i '' 's/\$(AppIdentifierPrefix)/'"${DEVELOPMENT_TEAM}"'./g' "$RUNNER_TEMP/original.entitlements"

          # Remove keychain-access-groups from build entitlements
          plutil -remove 'keychain-access-groups' "$ENTITLEMENTS_FILE" 2>/dev/null || true

          echo "=== Build entitlements (without keychain-access-groups) ==="
          cat "$ENTITLEMENTS_FILE"
          echo ""
          echo "=== Final entitlements (for re-signing) ==="
          cat "$RUNNER_TEMP/original.entitlements"

      - name: Build and Archive
        env:
          DEVELOPMENT_TEAM: ${{ secrets.DEVELOPMENT_TEAM }}
        run: |
          xcodebuild archive \
            -project "$PROJECT" \
            -scheme "$SCHEME" \
            -configuration Release \
            -destination "generic/platform=macOS" \
            -archivePath $RUNNER_TEMP/archive.xcarchive \
            DEVELOPMENT_TEAM="$DEVELOPMENT_TEAM" \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="Developer ID Application" \
            PROVISIONING_PROFILE_SPECIFIER="" \
            CODE_SIGN_INJECT_BASE_ENTITLEMENTS=NO \
            REGISTER_APP_GROUPS=NO \
            OTHER_CODE_SIGN_FLAGS="--timestamp"

      - name: Create ExportOptions.plist
        env:
          DEVELOPMENT_TEAM: ${{ secrets.DEVELOPMENT_TEAM }}
        run: |
          cat > $RUNNER_TEMP/ExportOptions.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>method</key>
              <string>developer-id</string>
              <key>teamID</key>
              <string>${DEVELOPMENT_TEAM}</string>
              <key>signingStyle</key>
              <string>manual</string>
              <key>signingCertificate</key>
              <string>Developer ID Application</string>
          </dict>
          </plist>
          EOF

      - name: Export App
        run: |
          xcodebuild -exportArchive \
            -archivePath $RUNNER_TEMP/archive.xcarchive \
            -exportPath $RUNNER_TEMP/export \
            -exportOptionsPlist $RUNNER_TEMP/ExportOptions.plist

      - name: Re-sign App with Keychain Entitlements
        run: |
          APP_PATH="$RUNNER_TEMP/export/$PRODUCT_NAME.app"

          # Sign nested components first (inside out) - frameworks, dylibs, XPC services
          # Sign all Mach-O binaries inside Frameworks
          if [ -d "$APP_PATH/Contents/Frameworks" ]; then
            find "$APP_PATH/Contents/Frameworks" -type f \( -name "*.dylib" -o -perm +111 \) 2>/dev/null | while read -r file; do
              # Check if it's a Mach-O binary
              if file "$file" | grep -q "Mach-O"; then
                codesign --force --sign "Developer ID Application" --options runtime --timestamp "$file" 2>/dev/null || true
              fi
            done

            # Sign framework bundles
            find "$APP_PATH/Contents/Frameworks" -name "*.framework" -type d 2>/dev/null | while read -r framework; do
              codesign --force --sign "Developer ID Application" --options runtime --timestamp "$framework"
            done
          fi

          # Sign XPC services if any
          find "$APP_PATH" -name "*.xpc" -type d 2>/dev/null | while read -r xpc; do
            codesign --force --sign "Developer ID Application" --options runtime --timestamp "$xpc"
          done

          # Finally sign the main app with entitlements
          codesign --force --sign "Developer ID Application" \
            --entitlements "$RUNNER_TEMP/original.entitlements" \
            --options runtime \
            --timestamp \
            "$APP_PATH"

          # Verify the signature
          codesign --verify --deep --strict "$APP_PATH"
          echo "Signature verification passed"

          echo "=== Entitlements in signed app ==="
          codesign -d --entitlements - "$APP_PATH"

      - name: Notarize App
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.DEVELOPMENT_TEAM }}
        run: |
          # Create ZIP for notarization
          cd $RUNNER_TEMP/export
          ditto -c -k --keepParent "$PRODUCT_NAME.app" "$PRODUCT_NAME-notorized.zip"

          # Submit for notarization
          xcrun notarytool submit "$PRODUCT_NAME-notorized.zip" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait

          # Staple the notarization ticket
          xcrun stapler staple "$PRODUCT_NAME.app"

      - name: "DMG: Install tool"
        run: |
          curl -L -o dmgs.tar.gz https://github.com/velocityzen/dmgs/releases/latest/download/dmgs.tar.gz
          tar -xzf dmgs.tar.gz
          chmod +x dmgs
          sudo mv dmgs /usr/local/bin/

      - name: "DMG: create .dmg"
        env:
          DEVELOPMENT_TEAM: ${{ secrets.DEVELOPMENT_TEAM }}
        run: dmgs create "$RUNNER_TEMP/export/$PRODUCT_NAME.app" "$DMG_BACKGROUND_FILE_NAME" --sign "$DEVELOPMENT_TEAM"

      - name: "DMG: Upload DMG Artifact"
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.PRODUCT_NAME }}-${{ steps.version.outputs.version }}
          path: ${{ env.PRODUCT_NAME }}.dmg

      - name: "Sparkle: Install CLI tools"
        run: |
          # Download Sparkle release with CLI tools
          mkdir sparkle
          cd sparkle
          curl -L -o sparkle.tar.xz https://github.com/sparkle-project/Sparkle/releases/download/2.8.1/Sparkle-2.8.1.tar.xz
          tar -xf sparkle.tar.xz
          # Make tools accessible
          chmod +x bin/generate_appcast
          sudo mv bin/generate_appcast /usr/local/bin/
          chmod +x bin/sign_update
          sudo mv bin/sign_update /usr/local/bin/
          cd ..
          rm -rf sparkle

      - name: "Sparkle: Sign update package"
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          # Sign the update with Sparkle's private key
          SIGNATURE=$(echo "$SPARKLE_PRIVATE_KEY" | sign_update --ed-key-file - "$PRODUCT_NAME.dmg")
          echo "SPARKLE_SIGNATURE=$SIGNATURE" >> $GITHUB_ENV
          FILE_SIZE=$(stat -f%z "$PRODUCT_NAME.dmg")
          echo "FILE_SIZE=$FILE_SIZE" >> $GITHUB_ENV

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create "${{ steps.version.outputs.version }}" \
            "${{ env.PRODUCT_NAME }}.dmg" \
            --title "${{ steps.version.outputs.version }}" \
            --notes "Version ${{ steps.version.outputs.version }}"

      - name: "Sparkle: Update appcast.xml"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          # if PRODUCT_NAME has spaces, replace them with dots
          DOWNLOAD_DMG_NAME="${PRODUCT_NAME// /.}.dmg"
          DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/$VERSION/$DOWNLOAD_DMG_NAME"
          PUB_DATE=$(date -R)

          # Create the new item XML in a temp file
          cat > item.xml << EOF

            <item>
                <title>Version $VERSION</title>
                <sparkle:version>$VERSION</sparkle:version>
                <pubDate>$PUB_DATE</pubDate>
                <sparkle:minimumSystemVersion>15.0</sparkle:minimumSystemVersion>
                <enclosure
                    url="$DOWNLOAD_URL"
                    ${{ env.SPARKLE_SIGNATURE }}
                    type="application/octet-stream" />
            </item>
          EOF

          # Insert the new item after <!-- new first --> marker (newest items first)
          sed -i '' '/<!-- new first -->/r item.xml' docs/appcast.xml

      - name: "Sparkle: Commit and push appcast.xml & new version changes"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add docs/appcast.xml
          git add "$PROJECT/project.pbxproj"
          git commit -m "Update appcast.xml for version ${{ steps.version.outputs.version }}"
          git push origin HEAD:main

      - name: Cleanup Keychain
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
